# MyOS – 32-bit Multitasking Kernel (x86)

> 从实模式启动到多任务调度的完整操作系统实现
> 15K+ 行代码 · 支持分页 · 用户态隔离 · 系统调用 · 简易文件系统

------

## 📌 项目概述

本项目基于 x86 架构，从 BIOS 启动阶段开始，实现一个支持：

- 保护模式切换
- 分页内存管理
- 内核态 / 用户态隔离
- 抢占式时间片调度
- fork 进程创建
- 简易文件系统
- 系统调用机制（int 0x80）

的 32 位操作系统原型。

> 目标：深入理解 CPU、内存管理、进程调度与中断机制的底层实现。

------

### ✅ CPU 架构理解

- 手动构建 GDT / IDT
- 配置 CR0 / CR3
- 开启分页机制
- 实现特权级切换（Ring0 → Ring3）
- TSS 支持任务切换

------

### ✅ 内存管理能力

- 物理内存位图管理
- 虚拟地址映射
- 页目录递归映射
- 内核堆 kmalloc 实现
- 用户空间独立页表

------

### ✅ 中断与系统调用

- 8259A 初始化
- 时钟中断驱动调度
- 键盘中断
- int 0x80 系统调用分发

------

### ✅ 进程与调度

- PCB 结构设计
- 双向链表调度队列
- 时间片轮转算法
- fork 实现
- 内核线程与用户进程统一管理

------

### ✅ 文件系统实现

- inode 结构
- 超级块
- 块位图管理
- 文件读写接口

------

## 🏗 系统架构图

模块划分：

```
Bootloader
   ↓
Memory Management
   ↓
Interrupt System
   ↓
Scheduler
   ↓
Filesystem
   ↓
User Process
```

------

## ⚙️ 开发环境

- 汇编：NASM
- C 编译器：GCC i386
- 调试工具：
  - **Bochs**
  - GDB

------

## 🚀 运行方式

```bash
make run
```

------

## 📊 项目规模

- 代码量：约 15,000 行
- 模块数：10+
- 系统调用：若干
- 支持多进程运行

------

## 🎯 项目收获

- 深入理解 CPU 特权级机制
- 掌握分页机制与地址转换
- 理解调度算法实现细节
- 明确“进程上下文切换”的本质

------

## 第九章

#### 4.通用异常处理函数是如何实现的？

该函数是一个通用中断/异常处理函数，用于处理未单独实现的异常。
它首先过滤 8259A 产生的 IRQ7 和 IRQ15 伪中断。
然后清空屏幕左上角区域，打印异常开始标志和异常名称。
如果异常为 Page Fault 缺页中断（向量号 14），则通过读取 CR2 寄存器获取导致缺页的线性地址并打印。
最后进入死循环，使系统停机，方便调试。
该函数通常作为 IDT 的默认异常入口函数。

#### 5.时钟中断处理函数是如何实现的？

该函数是时钟中断处理函数，由硬件定时器周期性触发。
它首先获取当前运行线程PCB，检查内核栈魔数防止栈溢出。
然后更新当前线程的运行时间和系统全局 tick 计数。
若当前线程时间片耗尽，则调用 schedule 进行进程调度；否则将时间片减一。
该机制实现了基于时间片的抢占式调度。

#### 6.如何获取当前线程pcb指针？

通过读取 ESP 寄存器获取当前内核栈地址。
由于每个线程的 PCB 和内核栈共用一个 4KB 页，并且 PCB 位于页的低地址处，因此将 ESP 与 0xFFFFF000 进行按位与运算，得到页起始地址，即当前线程的 PCB 地址。

#### 7.把内核主线程(main)纳入线程管理体系是如何实现的？为什么需要这个函数？

原因：
在内核启动时CPU 早已在执行 main：
	但此时还没有线程管理结构
	main 只是普通执行流
为了实现统一调度：
	必须把 main 包装成一个线程（PCB）

该函数用于将内核启动阶段已经执行的 main 函数封装为线程控制块。
由于 main 线程的 PCB 和内核栈在 loader 阶段已经预留，因此无需重新分配内存。
函数通过 running_thread 获取当前 PCB，并调用 init_thread 进行初始化。
最后将其加入所有线程链表 thread_all_list，但不加入就绪队列，因为当前线程正在运行。
该设计保证了 main 线程可以统一纳入线程调度管理体系。

#### 8.如何设计线程切换的底层实现？

switch_to 函数用于完成线程上下文切换。
它首先保存当前线程的通用寄存器，并将当前 ESP 保存到当前线程 PCB 的 self_kstack 字段中。
然后加载下一个线程的 self_kstack 到 ESP，从而切换到下一个线程的内核栈。
随后恢复寄存器并执行 ret 指令，跳转到下一个线程之前保存的执行位置。
该函数本质通过切换栈指针实现线程切换。

